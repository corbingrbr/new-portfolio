import React, { useState, useEffect } from "react";
//import './style.css'
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import * as dat from "lil-gui";
import * as CANNON from "cannon-es";

function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}

const Colors = {
  CYAN: "#00FFFF",
  MAGENTA: "#FF00FF",
  YELLOW: "#FFFF00",
  BLACK: "#000000",
};

export default function Welcome() {
  let logo = [
    { letter: "G", color: "green" /*"cyan"*/ },
    { letter: "R", color: "red" /*"magenta"*/ },
    { letter: "B", color: "blue" /*"yellow"*/ },
    { letter: "R", color: "black" },
  ];

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() => {
    setup();
  });

  return <canvas className="h-screen webgl" />;
}

/**
 * Debug
 */
const gui = new dat.GUI();
const debugObject = {};

debugObject.createBox = () => {
  createBox(Math.random(), Math.random(), Math.random(), {
    x: (Math.random() - 0.5) * 3,
    y: 3,
    z: (Math.random() - 0.5) * 3,
  });
};
gui.add(debugObject, "createBox");

// Reset
debugObject.reset = () => {
  for (const object of objectsToUpdate) {
    // Remove body
    //object.body.removeEventListener('collide', playHitSound)
    world.removeBody(object.body);

    // Remove mesh
    scene.remove(object.mesh);
  }

  objectsToUpdate.splice(0, objectsToUpdate.length);
};
gui.add(debugObject, "reset");

let renderer;
let camera;
let canvas;
let controls;

// This needs to occur after the component mounts because it requires canvas to be present
const setup = () => {
  canvas = document.querySelector("canvas.webgl");

  /**
   * Camera
   */
  // Base camera
  const frustumSize = 12;
  const aspect = sizes.width / sizes.height;

  camera = new THREE.OrthographicCamera(
    (-frustumSize * aspect) / 2,
    (frustumSize * aspect) / 2,
    frustumSize / 2,
    -frustumSize / 2,
    -1000,
    1000
  );

  scene.add(camera);
  scene.background = new THREE.Color(0xf0f0f0);

  // Controls
  controls = new OrbitControls(camera, canvas);
  controls.enableDamping = true;

  /**
   * Renderer
   */
  renderer = new THREE.WebGLRenderer({
    canvas: canvas,
  });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.setSize(sizes.width, sizes.height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  /**
   * Floor
   */
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(
      frustumSize * aspect - frustumSize / 9,
      frustumSize - frustumSize / 9
    ),
    new THREE.MeshBasicMaterial({
      color: "#FFFFFF",
      //metalness: 0.3,
      //roughness: 0.4,
      //envMap: environmentMapTexture,
      //envMapIntensity: 0.5
    })
  );

  floor.receiveShadow = true;
  scene.add(floor);

  // wireframe
  var geo = new THREE.EdgesGeometry(floor.geometry); // or WireframeGeometry
  var mat = new THREE.LineBasicMaterial({
    color: "#000000",
    linewidth: 20,
    linecap: "round", //ignored by WebGLRenderer
    linejoin: "round", //ignored by WebGLRenderer
  });
  var wireframe = new THREE.LineSegments(geo, mat);
  floor.add(wireframe);

  /**
   * Pockets
   */
  const POCKET_SIZE = frustumSize / 10;

  //const pocket_material = new THREE.MeshStandardMaterial({ color: '#9BA3AF' });
  const pocket_material = new THREE.MeshStandardMaterial({ color: "E4E7EB" });

  // flat shape with texture
  // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
  const pocketShape = new THREE.Shape()
    .lineTo(-POCKET_SIZE / 2, 0)
    .lineTo(-POCKET_SIZE / 2, POCKET_SIZE / 3)
    .absarc(0, POCKET_SIZE / 3, POCKET_SIZE / 2, Math.PI, 0, true)
    .lineTo(POCKET_SIZE / 2, 0);

  let pocketGeometry = new THREE.ShapeGeometry(pocketShape);

  // wireframe
  //var geo = new THREE.EdgesGeometry(floor.geometry); // or WireframeGeometry

  var pocket_wireframe = new THREE.LineSegments(pocketGeometry, mat);

  [
    {
      x: (-frustumSize * aspect) / 2 + POCKET_SIZE,
      y: frustumSize / 2 - POCKET_SIZE,
      r: Math.PI / 4,
    }, // TOP LEFT
    {
      x: (-frustumSize * aspect) / 2 + POCKET_SIZE,
      y: -frustumSize / 2 + POCKET_SIZE,
      r: (3 * Math.PI) / 4,
    }, // BOTTOM LEFT
    {
      x: (frustumSize * aspect) / 2 - POCKET_SIZE,
      y: frustumSize / 2 - POCKET_SIZE,
      r: -Math.PI / 4,
    }, // TOP RIGHT
    {
      x: (frustumSize * aspect) / 2 - POCKET_SIZE,
      y: -frustumSize / 2 + POCKET_SIZE,
      r: (-3 * Math.PI) / 4,
    }, // BOTTOM RIGHT
  ].forEach((position) => {
    let mesh = new THREE.Mesh(pocketGeometry, pocket_material);
    mesh.position.set(position.x, position.y, 1);
    mesh.scale.set(POCKET_SIZE, POCKET_SIZE, POCKET_SIZE);
    mesh.rotation.set(0, 0, position.r);
    scene.add(mesh);

    mesh.add(pocket_wireframe);
  });

  /**
   * Balls
   */
  const BALL_SIZE = frustumSize / 20;

  // Create sphere

  //const sphereMaterial = new THREE.MeshStandardMaterial({ color: '#FF0000' })
  const sphereGeometry = new THREE.SphereGeometry(1, 20, 20);

  const MARGIN = BALL_SIZE / 10;

  [
    {
      x: -BALL_SIZE - MARGIN,
      y: BALL_SIZE + MARGIN,
      color: Colors.CYAN,
      letter: "G",
      img: "/assets/billiard/striped_green.png",
    }, // TOP LEFT
    {
      x: BALL_SIZE + MARGIN,
      y: BALL_SIZE + MARGIN,
      color: Colors.YELLOW,
      letter: "R",
      img: "/assets/billiard/striped_red.png",
    }, // TOP RIGHT
    {
      x: -BALL_SIZE - MARGIN,
      y: -BALL_SIZE - MARGIN,
      color: Colors.MAGENTA,
      letter: "B",
      img: "/assets/billiard/striped_blue.png",
    }, // BOTTOM LEFT
    {
      x: BALL_SIZE + MARGIN,
      y: -BALL_SIZE - MARGIN,
      color: Colors.BLACK,
      letter: "R",
      img: "/assets/billiard/8_ball.png",
    }, // BOTTOM RIGHT
  ].forEach((ball) => {
    //createSphere(BALL_SIZE, {x: position.x, y: position.y, z: BALL_SIZE});

    const texture = new THREE.TextureLoader().load(ball.img);

    // immediately use the texture for material creation
    const material = new THREE.MeshStandardMaterial({ map: texture });

    //const canvas = makeLabelCanvas(2000, 500, ball.letter, ball.color);
    //const letter_texture = new THREE.CanvasTexture(canvas);
    //let material = new THREE.MeshBasicMaterial({ color: ball.color, map: letter_texture, transparent: true })

    let mesh = new THREE.Mesh(sphereGeometry, material);
    mesh.scale.set(BALL_SIZE, BALL_SIZE, BALL_SIZE);
    mesh.position.set(ball.x, ball.y, BALL_SIZE);
    //mesh.rotation.set(0, 11, 0);

    objectsToUpdate.push({ mesh: mesh });
    scene.add(mesh);
  });

  tick();

  window.addEventListener("resize", () => {
    // Update sizes
    sizes.width = window.innerWidth;
    sizes.height = window.innerHeight;

    // Update camera
    camera.aspect = sizes.width / sizes.height;
    camera.updateProjectionMatrix();

    // Resize the game elements, like the pockets/balls

    // Update renderer
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  });
};

function makeLabelCanvas(baseWidth, size, name, color) {
  const ctx = document.createElement("canvas").getContext("2d");

  const font = `${size}px sans-serif`;
  ctx.font = font;
  // measure how long the name will be
  const textWidth = ctx.measureText(name).width;

  const width = baseWidth;
  const height = baseWidth;
  ctx.canvas.width = width;
  ctx.canvas.height = height;

  // need to set font again after resizing canvas
  ctx.font = font;
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";

  ctx.fillStyle = color;
  ctx.fillRect(0, 0, width, height);

  // scale to fit but don't stretch
  const scaleFactor = Math.min(1, baseWidth / textWidth);
  ctx.translate(width / 2, height / 2);
  ctx.scale(scaleFactor, scaleFactor);
  ctx.fillStyle = "#111111";
  ctx.fillText(name, 0, 0);

  return ctx.canvas;
}

/**
 * Base
 */
// Canvas

// Scene
const scene = new THREE.Scene();

/**
 * Sounds
 */
/*const hitSound = new Audio('/sounds/hit.mp3')
 
const playHitSound = (collision) => {
    const impactStrength = collision.contact.getImpactVelocityAlongNormal()
 
    if (impactStrength > 1.5) {
        hitSound.volume = Math.random()
        hitSound.currentTime = 0
        hitSound.play()
    }
}*/

/**
 * Physics
 */
const world = new CANNON.World();
world.broadphase = new CANNON.SAPBroadphase(world);
world.allowSleep = true;
world.gravity.set(0, -9.82, 0);

// Default material
const defaultMaterial = new CANNON.Material("default");
const defaultContactMaterial = new CANNON.ContactMaterial(
  defaultMaterial,
  defaultMaterial,
  {
    friction: 0.1,
    restitution: 0.7,
  }
);
world.defaultContactMaterial = defaultContactMaterial;

// Floor
const floorShape = new CANNON.Plane();
const floorBody = new CANNON.Body();
floorBody.mass = 0;
floorBody.addShape(floorShape);
floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(-1, 0, 0), Math.PI * 0.5);
world.addBody(floorBody);

/**
 * Utils
 */
const objectsToUpdate = [];

/*const createSphere = (radius, position) => {
    // Three.js mesh
    const mesh = new THREE.Mesh(sphereGeometry, sphereMaterial)
    mesh.castShadow = true
    mesh.scale.set(radius, radius, radius)
    mesh.position.copy(position)
    scene.add(mesh)
 
    // Cannon.js body
    const shape = new CANNON.Sphere(radius)
 
    const body = new CANNON.Body({
        mass: 1,
        position: new CANNON.Vec3(0, 3, 0),
        shape: shape,
        material: defaultMaterial
    })
    body.position.copy(position)
    //body.addEventListener('collide', playHitSound)
    world.addBody(body)
 
    // Save in objects
    objectsToUpdate.push({ mesh, body })
}*/

// Create box
const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
const boxMaterial = new THREE.MeshStandardMaterial({
  metalness: 0.3,
  roughness: 0.4,
  color: "#FF0000",
  //envMap: environmentMapTexture,
  //envMapIntensity: 0.5
});
const createBox = (width, height, depth, position) => {
  // Three.js mesh
  const mesh = new THREE.Mesh(boxGeometry, boxMaterial);
  mesh.scale.set(width, height, depth);
  mesh.castShadow = true;
  mesh.position.copy(position);
  scene.add(mesh);

  // Cannon.js body
  const shape = new CANNON.Box(
    new CANNON.Vec3(width * 0.5, height * 0.5, depth * 0.5)
  );

  const body = new CANNON.Body({
    mass: 1,
    position: new CANNON.Vec3(0, 3, 0),
    shape: shape,
    material: defaultMaterial,
  });
  body.position.copy(position);
  //body.addEventListener('collide', playHitSound)
  world.addBody(body);

  // Save in objects
  objectsToUpdate.push({ mesh, body });
};

//createBox(1, 1.5, 2, { x: 0, y: 3, z: 0 })

//createBox(10, 1, 1, { x: 0, y: 0, z: -4 })

//floor.rotation.x = - Math.PI * 0.5

/**
 * Lights
 */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.set(1024, 1024);
directionalLight.shadow.camera.far = 15;
directionalLight.shadow.camera.left = -7;
directionalLight.shadow.camera.top = 7;
directionalLight.shadow.camera.right = 7;
directionalLight.shadow.camera.bottom = -7;
directionalLight.position.set(5, 5, 5);
scene.add(directionalLight);

/**
 * Sizes
 */
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight,
};

/**
 * Animate
 */
const clock = new THREE.Clock();
let oldElapsedTime = 0;

const tick = () => {
  const elapsedTime = clock.getElapsedTime();
  const deltaTime = elapsedTime - oldElapsedTime;
  oldElapsedTime = elapsedTime;

  // Update physics
  world.step(1 / 60, deltaTime, 3);

  for (const object of objectsToUpdate) {
    //object.mesh.position.copy(object.body.position)
    //object.mesh.quaternion.copy(object.body.quaternion)
    object.mesh.rotation.set(elapsedTime, elapsedTime, elapsedTime);
  }

  // Update controls
  controls.update();

  // Render
  renderer.render(scene, camera);

  // Call tick again on the next frame
  window.requestAnimationFrame(tick);
};
